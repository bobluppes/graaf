"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[69],{766:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"algorithms/minimum-spanning-tree/prim","title":"Prim\'s Algorithm","description":"Prim\'s algorithm computes the minimum spanning tree (MST) of a connected, undirected graph with weighted edges. Starting","source":"@site/docs/algorithms/minimum-spanning-tree/prim.md","sourceDirName":"algorithms/minimum-spanning-tree","slug":"/algorithms/minimum-spanning-tree/prim","permalink":"/graaf/docs/algorithms/minimum-spanning-tree/prim","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/minimum-spanning-tree/prim.md","tags":[],"version":"current","frontMatter":{},"sidebar":"algorithmSidebar","previous":{"title":"Kruskal\'s Algorithm","permalink":"/graaf/docs/algorithms/minimum-spanning-tree/kruskal"},"next":{"title":"Shortest Path Algorithms","permalink":"/graaf/docs/category/shortest-path-algorithms"}}');var i=n(4848),s=n(8453);const a={},o="Prim's Algorithm",h={},m=[{value:"Syntax",id:"syntax",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"prims-algorithm",children:"Prim's Algorithm"})}),"\n",(0,i.jsx)(t.p,{children:"Prim's algorithm computes the minimum spanning tree (MST) of a connected, undirected graph with weighted edges. Starting\nwith an arbitrary vertex, the algorithm iteratively selects the edge with the smallest weight that connects a\nvertex in the tree to a vertex outside the tree, adding it to the MST."}),"\n",(0,i.jsx)(t.p,{children:"The algorithm's worst-case time complexity is O(\u2223E\u2223log\u2223V\u2223)."}),"\n",(0,i.jsx)(t.p,{children:"Unlike Kruskal's algorithm, Prim's algorithm works efficiently on dense graphs. A limitation is that it requires the\ngraph to be connected and does not handle disconnected graphs or graphs with negative-weight cycles."}),"\n",(0,i.jsx)(t.p,{children:"Prim's MST is often used in network design, such as electrical wiring and telecommunications."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm",children:"wikipedia"})}),"\n",(0,i.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"template <typename V, typename E>\n[[nodiscard]] std::optional<std::vector<edge_id_t> > prim_minimum_spanning_tree(\n    const graph<V, E, graph_type::UNDIRECTED>& graph, vertex_id_t start_vertex);\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"graph"})," The undirected graph for which we want to compute the MST."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"start_vertex"})," The vertex ID which should be the root of the MST."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"return"})," Returns a vector of edges that form MST if the graph is connected, otherwise returns an empty optional."]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);