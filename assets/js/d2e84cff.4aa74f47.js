"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[157],{6749:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"algorithms/cycle-detection/dfs-based","title":"DFS Based Cycle Detection","description":"A DFS based cycle detection algorithm is used to identify cycles in graphs, both directed and undirected.","source":"@site/docs/algorithms/cycle-detection/dfs-based.md","sourceDirName":"algorithms/cycle-detection","slug":"/algorithms/cycle-detection/dfs-based","permalink":"/graaf/docs/algorithms/cycle-detection/dfs-based","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/cycle-detection/dfs-based.md","tags":[],"version":"current","frontMatter":{},"sidebar":"algorithmSidebar","previous":{"title":"Cycle Detection Algorithms","permalink":"/graaf/docs/category/cycle-detection-algorithms"},"next":{"title":"Minimum Spanning Tree","permalink":"/graaf/docs/category/minimum-spanning-tree"}}');var r=t(4848),s=t(8453);const c={},a="DFS Based Cycle Detection",d={},l=[{value:"Syntax",id:"syntax",level:2},{value:"Similar algorithms",id:"similar-algorithms",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"dfs-based-cycle-detection",children:"DFS Based Cycle Detection"})}),"\n",(0,r.jsx)(n.p,{children:"A DFS based cycle detection algorithm is used to identify cycles in graphs, both directed and undirected.\nThe algorithm can be used to detect cycles in the structure of a graph, as it does not consider edge weights."}),"\n",(0,r.jsx)(n.h1,{id:"directed-graph",children:"Directed graph"}),"\n",(0,r.jsx)(n.p,{children:"The key idea is that when a vertex is processed, mark it as: UNVISITED, VISITED and NO_CYCLE.\nBy default all vertices marked as UNVISITED. During the traversal, we label vertices as VISITED. At the exit of the\nrecursion, we label the vertex as NO CYCLE.\nIf we met a vertex labeled VISITED, we found a cycle in the graph."}),"\n",(0,r.jsx)(n.h1,{id:"undirected-graph",children:"Undirected graph"}),"\n",(0,r.jsx)(n.p,{children:"The key idea is to store the parent of each vertex during the traversal. So when we check neighboring vertices, we skip\nback edge.\nDuring the traversal we mark the vertex as visited and continue the traversal. In case a vertex was visited before and\nvertices have different parents, we found a cycle."}),"\n",(0,r.jsxs)(n.p,{children:["The runtime of the algorithm is ",(0,r.jsx)(n.code,{children:"O(|V| + |E|)"})," and memory consumption is ",(0,r.jsx)(n.code,{children:"O(|V|)"}),". Where V is the number of vertices in\nthe graph and E the number of edges.\nThe algorithm uses DFS traversal and therefore suffers the same limitations (see depth-first-search.md)."]}),"\n",(0,r.jsx)(n.h1,{id:"use-cases",children:"Use cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Resource dependencies:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Redundant connections."}),"\n",(0,r.jsx)(n.li,{children:"Deadlocks in concurrent systems."}),"\n",(0,r.jsx)(n.li,{children:"Deadlocks in concurrent systems."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Logical dependencies:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Data base relation."}),"\n",(0,r.jsx)(n.li,{children:"Dependency management."}),"\n",(0,r.jsx)(n.li,{children:"Circuit design."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Infinity loops."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cycle_(graph_theory)#Cycle_detection",children:"wikipedia"})}),"\n",(0,r.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(n.p,{children:"Cycle detection for directed graph."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename V, typename E>\n[[nodiscard]] bool dfs_cycle_detection(\n    const graph<V, E, graph_type::DIRECTED> &graph);\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Cycle detection for unidrected graph."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename V, typename E>\n[[nodiscard]] bool dfs_cycle_detection(\n    const graph<V, E, graph_type::UNDIRECTED> &graph);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"graph"})," The graph to traverse."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"return"})," Returns true in case of cycle otherwise returns false."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"similar-algorithms",children:"Similar algorithms"}),"\n",(0,r.jsxs)(n.p,{children:["There are many algorithms for cycle detection or algorithms with specific cycle conditions.\nSee ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cycle_(graph_theory)#Graph_classes_defined_by_cycle",children:"wikipedia"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);