"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[479],{3767:(t,o,e)=>{e.r(o),e.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"algorithms/topological-sort/topological-sort","title":"Topological sort algorithm","description":"Topological sort algorithm processing DAG(directed acyclic graph) using DFS traversal.","source":"@site/docs/algorithms/topological-sort/topological-sort.md","sourceDirName":"algorithms/topological-sort","slug":"/algorithms/topological-sort/","permalink":"/graaf/docs/algorithms/topological-sort/","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/topological-sort/topological-sort.md","tags":[],"version":"current","frontMatter":{},"sidebar":"algorithmSidebar","previous":{"title":"Tarjan\'s Strongly Connected Components","permalink":"/graaf/docs/algorithms/strongly-connected-components/tarjan"},"next":{"title":"Traversal Algorithms","permalink":"/graaf/docs/category/traversal-algorithms"}}');var n=e(4848),s=e(8453);const a={},i="Topological sort algorithm",l={},c=[{value:"Syntax",id:"syntax",level:2}];function d(t){const o={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"topological-sort-algorithm",children:"Topological sort algorithm"})}),"\n",(0,n.jsxs)(o.p,{children:["Topological sort algorithm processing DAG(directed acyclic graph) using DFS traversal.\nEach vertex is visited only after all its dependencies are visited.\nThe runtime of the algorithm is ",(0,n.jsx)(o.code,{children:"O(|V|+|E|)"})," and the memory consumption is ",(0,n.jsx)(o.code,{children:"O(|V|)"}),"."]}),"\n",(0,n.jsx)(o.p,{children:(0,n.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Topological_sorting",children:"wikipedia"})}),"\n",(0,n.jsx)(o.h2,{id:"syntax",children:"Syntax"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-cpp",children:"template <typename V, typename E>\n[[nodiscard]] std::optional<std::vector<vertex_id_t>> topological_sort(\n    const graph<V, E, graph_type::DIRECTED>& graph);\n"})}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"graph"})," The directed graph to traverse."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"return"})," Vector of vertices sorted in topological order. If the graph contains cycles, it returns std::nullopt."]}),"\n"]})]})}function p(t={}){const{wrapper:o}={...(0,s.R)(),...t.components};return o?(0,n.jsx)(o,{...t,children:(0,n.jsx)(d,{...t})}):d(t)}},8453:(t,o,e)=>{e.d(o,{R:()=>a,x:()=>i});var r=e(6540);const n={},s=r.createContext(n);function a(t){const o=r.useContext(s);return r.useMemo((function(){return"function"==typeof t?t(o):{...o,...t}}),[o,t])}function i(t){let o;return o=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:a(t.components),r.createElement(s.Provider,{value:o},t.children)}}}]);