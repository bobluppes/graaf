"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[849],{8443:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>h,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"algorithms/shortest-path/dijkstra","title":"Dijkstra Shortest Path","description":"Dijkstra\'s algorithm computes shortest paths between nodes in weighted and unweighted graphs. In weighted graphs,","source":"@site/docs/algorithms/shortest-path/dijkstra.md","sourceDirName":"algorithms/shortest-path","slug":"/algorithms/shortest-path/dijkstra","permalink":"/graaf/docs/algorithms/shortest-path/dijkstra","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/shortest-path/dijkstra.md","tags":[],"version":"current","frontMatter":{},"sidebar":"algorithmSidebar","previous":{"title":"BFS Based Shortest Path","permalink":"/graaf/docs/algorithms/shortest-path/bfs-based-shortest-path"},"next":{"title":"Floyd-Warshall algorithm","permalink":"/graaf/docs/algorithms/shortest-path/floyd-warshall"}}');var n=s(4848),a=s(8453);const h={},i="Dijkstra Shortest Path",o={},d=[{value:"Syntax",id:"syntax",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"dijkstra-shortest-path",children:"Dijkstra Shortest Path"})}),"\n",(0,n.jsxs)(t.p,{children:["Dijkstra's algorithm computes shortest paths between nodes in weighted and unweighted graphs. In weighted graphs,\nedge weights should be non-negative. Dijkstra's algorithm is implemented with a priority queue and runs\nin ",(0,n.jsx)(t.code,{children:"O(|E|log|V|)"})," for connected graphs, where ",(0,n.jsx)(t.code,{children:"|E|"})," is the number of edges and ",(0,n.jsx)(t.code,{children:"|V|"})," the number of vertices in the\ngraph."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm",children:"wikipedia"})}),"\n",(0,n.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,n.jsx)(t.p,{children:"calculates the shortest path between on start_vertex and one end_vertex using Dijkstra's algorithm. Works on both\nweighted as well as unweighted graphs. For unweighted graphs, a unit weight is used for each edge."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"template <typename V, typename E, graph_type T, typename WEIGHT_T = decltype(get_weight(std::declval<E>()))>\nstd::optional<graph_path<WEIGHT_T>> \ndijkstra_shortest_path(const graph<V, E, T>& graph, vertex_id_t start_vertex, vertex_id_t end_vertex);\n"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"graph"})," The graph to extract shortest path from."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"start_vertex"})," Vertex id where the shortest path should start."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"end_vertex"})," Vertex id where the shortest path should end."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"return"})," An optional with the shortest path (list of vertices) if found."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Find the shortest paths from a source vertex to all other vertices in the graph using Dijkstra's algorithm."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"template <typename V, typename E, graph_type T, typename WEIGHT_T = decltype(get_weight(std::declval<E>()))>\n[[nodiscard]] std::unordered_map<vertex_id_t, graph_path<WEIGHT_T>>\ndijkstra_shortest_paths(const graph<V, E, T>& graph, vertex_id_t source_vertex);\n"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"graph"})," The graph we want to search."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"source_vertex"})," The source vertex from which to compute shortest paths."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"return"})," A map containing the shortest paths from the source vertex to all other vertices. The map keys are target\nvertex IDs, and the values are instances of graph_path, representing the shortest distance and the path (list of\nvertex IDs) from the source to the target. If a vertex is not reachable from the source, its entry will be absent from\nthe map."]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>h,x:()=>i});var r=s(6540);const n={},a=r.createContext(n);function h(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:h(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);