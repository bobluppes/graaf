"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[870],{1165:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>h,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"examples/example-basics/shortest-path","title":"Shortest Path Example","description":"The shortest path algorithm implemented in graaf::getshortestpath can be used to compute the shortest","source":"@site/docs/examples/example-basics/shortest-path.md","sourceDirName":"examples/example-basics","slug":"/examples/example-basics/shortest-path","permalink":"/graaf/docs/examples/example-basics/shortest-path","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/examples/example-basics/shortest-path.md","tags":[],"version":"current","frontMatter":{},"sidebar":"exampleSidebar","previous":{"title":"Dot Serialization Example","permalink":"/graaf/docs/examples/example-basics/dot-serialization"},"next":{"title":"Network Example","permalink":"/graaf/docs/examples/example-basics/transport-example"}}');var a=s(4848),n=s(8453);const o={},h="Shortest Path Example",i={},c=[{value:"Visualizing the shortest path",id:"visualizing-the-shortest-path",level:2}];function l(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"shortest-path-example",children:"Shortest Path Example"})}),"\n",(0,a.jsxs)(t.p,{children:["The shortest path algorithm implemented in ",(0,a.jsx)(t.code,{children:"graaf::algorithm::get_shortest_path"})," can be used to compute the shortest\npath between any two vertices in a graph."]}),"\n",(0,a.jsx)(t.p,{children:"Consider the following graph:"}),"\n",(0,a.jsx)("pre",{children:(0,a.jsx)("p",{align:"center",children:(0,a.jsx)("img",{src:s(5561).A})})}),"\n",(0,a.jsxs)(t.p,{children:["In order to compute the shortest path between ",(0,a.jsx)(t.em,{children:"vertex 0"})," and ",(0,a.jsx)(t.em,{children:"vertex 2"}),", we call:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:"const auto maybe_shortest_path{bfs_shortest_path(graph, start, target)};\n\n// Assert that we found a path at all\nassert(maybe_shortest_path.has_value());\nauto shortest_path{maybe_shortest_path.value()};\n"})}),"\n",(0,a.jsx)(t.h2,{id:"visualizing-the-shortest-path",children:"Visualizing the shortest path"}),"\n",(0,a.jsx)(t.p,{children:"If we want to visualize the shortest path on the graph, we can create our own vertex and edge writers. These writers\nthen determine the vertex and edge attributes based on whether the vertex or edge is contained in the shortest path."}),"\n",(0,a.jsx)(t.p,{children:"First, we create a datastructure of all edges on the shortest path such that we can query it in the edge writer:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:"// We use a set here for O(1) time contains checks\nstd::unordered_set<graaf::vertex_ids_t, graaf::vertex_ids_hash> edges_on_shortest_path{};\n\n// Convert the list of vertices on the shortest path to edges\ngraaf::vertex_id_t prev{shortest_path.vertices.front()};\nshortest_path.vertices.pop_front();\nfor (const auto current : shortest_path.vertices) {\n  edges_on_shortest_path.insert(std::make_pair(prev, current));\n  prev = current;\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Now we can specify our custom writers:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'const auto vertex_writer{\n  [start, target](graaf::vertex_id_t vertex_id, int vertex) -> std::string {\n    if (vertex_id == start) {\n      return "label=start";\n    } else if (vertex_id == target) {\n      return "label=target";\n    }\n    return "label=\\"\\"";\n}};\n\nconst auto edge_writer{\n[&edges_on_shortest_path](const graaf::vertex_ids_t& edge_id, int edge) -> std::string {\n  if (edges_on_shortest_path.contains(edge_id)) {\n    return "label=\\"\\", color=red";\n  }\n  return "label=\\"\\", color=gray, style=dashed";\n}};\n'})}),"\n",(0,a.jsx)(t.p,{children:"This yields us the following visualization:"}),"\n",(0,a.jsx)("pre",{children:(0,a.jsx)("p",{align:"center",children:(0,a.jsx)("img",{src:s(3732).A})})})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},5561:(e,t,s)=>{s.d(t,{A:()=>r});const r=s.p+"assets/images/shortest-path-graph-52705b459836d4e0df3652fc6cb5f383.png"},3732:(e,t,s)=>{s.d(t,{A:()=>r});const r=s.p+"assets/images/shortest_path-066884c91f07b897658ade288f01ace8.png"},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>h});var r=s(6540);const a={},n=r.createContext(a);function o(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);