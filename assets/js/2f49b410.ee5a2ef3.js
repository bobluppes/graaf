"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[615],{6600:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"algorithms/minimum-spanning-tree/kruskal","title":"Kruskal\'s Algorithm","description":"Kruskal\'s algorithm finds the minimum spanning forest of an undirected edge-weighted graph. If the graph is connected,","source":"@site/docs/algorithms/minimum-spanning-tree/kruskal.md","sourceDirName":"algorithms/minimum-spanning-tree","slug":"/algorithms/minimum-spanning-tree/kruskal","permalink":"/graaf/docs/algorithms/minimum-spanning-tree/kruskal","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/minimum-spanning-tree/kruskal.md","tags":[],"version":"current","frontMatter":{},"sidebar":"algorithmSidebar","previous":{"title":"Minimum Spanning Tree","permalink":"/graaf/docs/category/minimum-spanning-tree"},"next":{"title":"Prim\'s Algorithm","permalink":"/graaf/docs/algorithms/minimum-spanning-tree/prim"}}');var r=t(4848),s=t(8453);const a={},o="Kruskal's Algorithm",c={},d=[{value:"Syntax",id:"syntax",level:2},{value:"Special case",id:"special-case",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"kruskals-algorithm",children:"Kruskal's Algorithm"})}),"\n",(0,r.jsxs)(n.p,{children:["Kruskal's algorithm finds the minimum spanning forest of an undirected edge-weighted graph. If the graph is connected,\nit finds a minimum spanning tree.\nThe algorithm is implemented with disjoint set union and finding minimum weighted edges.\nWorst-case performance is ",(0,r.jsx)(n.code,{children:"O(|E|log|V|)"}),", where ",(0,r.jsx)(n.code,{children:"|E|"})," is the number of edges and ",(0,r.jsx)(n.code,{children:"|V|"})," is the number of vertices in the\ngraph. Memory usage is ",(0,r.jsx)(n.code,{children:"O(V+E)"})," for maintaining vertices (DSU) and edges."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm",children:"wikipedia"})}),"\n",(0,r.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(n.p,{children:"Calculates the shortest path with the minimum edge sum."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename V, typename E>\n[[nodiscard]] std::vector<edge_id_t> kruskal_minimum_spanning_tree(\n    const graph<V, E, graph_type::UNDIRECTED>& graph);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"graph"})," The graph to extract MST or MSF."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"return"})," Returns a vector of edges that form MST if the graph is connected, otherwise it returns the minimum\nspanning forest."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"special-case",children:"Special case"}),"\n",(0,r.jsx)(n.p,{children:"In case of multiply edges with same weight leading to a vertex, prioritizing vertices with lesser vertex number."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"std::sort(edges_to_process.begin(), edges_to_process.end(),\n              [](detail::edge_to_process<E>& e1,\n                 detail::edge_to_process<E>& e2) {\n                       if (e1 != e2)\n                           return e1.get_weight() < e2.get_weight();\n          return e1.vertex_a < e2.vertex_a || e1.vertex_b < e2.vertex_b;\n        });\n"})}),"\n",(0,r.jsx)(n.p,{children:"For custom type edge, we should provide < and != operators"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct custom_edge : public graaf::weighted_edge<int> {\n public:\n  int weight_{};\n\n  [[nodiscard]] int get_weight() const noexcept override { return weight_; }\n \n  custom_edge(int weight): weight_{weight} {};\n  custom_edge(){};\n  ~custom_edge(){};\n\n  // Providing '<' and '!=' operators for sorting edges\n  bool operator<(const custom_edge& e) const noexcept {\n    return this->weight_ < e.weight_;\n  }\n  bool operator!=(const custom_edge& e) const noexcept {\n    return this->weight_ != e.weight_;\n  }\n};\n"})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);