"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[241],{8235:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>h,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>i});const s=JSON.parse('{"id":"algorithms/shortest-path/bellman-ford","title":"Bellman-Ford Shortest Path","description":"Bellman-Ford\'s algorithm computes shortest paths from a single source vertex to all of the other vertices in weighted","source":"@site/docs/algorithms/shortest-path/bellman-ford.md","sourceDirName":"algorithms/shortest-path","slug":"/algorithms/shortest-path/bellman-ford","permalink":"/graaf/docs/algorithms/shortest-path/bellman-ford","draft":false,"unlisted":false,"editUrl":"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/shortest-path/bellman-ford.md","tags":[],"version":"current","frontMatter":{},"sidebar":"algorithmSidebar","previous":{"title":"A* Search Algorithm","permalink":"/graaf/docs/algorithms/shortest-path/a-star"},"next":{"title":"BFS Based Shortest Path","permalink":"/graaf/docs/algorithms/shortest-path/bfs-based-shortest-path"}}');var a=r(4848),n=r(8453);const o={},h="Bellman-Ford Shortest Path",l={},i=[{value:"Syntax",id:"syntax",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"bellman-ford-shortest-path",children:"Bellman-Ford Shortest Path"})}),"\n",(0,a.jsxs)(t.p,{children:["Bellman-Ford's algorithm computes shortest paths from a single source vertex to all of the other vertices in weighted\ngraph and unweighted graphs. In weighted graphs, edge weights are allowed to be negative. Bellman-Ford's algorithm runs\nin ",(0,a.jsx)(t.code,{children:"O(|E||V|)"})," for connected graphs, where ",(0,a.jsx)(t.code,{children:"|E|"})," is the number of edges and ",(0,a.jsx)(t.code,{children:"|V|"})," the number of vertices in the\ngraph."]}),"\n",(0,a.jsx)(t.p,{children:"A limitation is that this implementation doesn't check for negative-weight cycles."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm",children:"wikipedia"})}),"\n",(0,a.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,a.jsx)(t.p,{children:"Find the shortest paths from a source vertex to all other vertices using the Bellman-Ford algorithm."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"template <typename V, typename E, graph_type T, \n          typename WEIGHT_T = decltype(get_weight(std::declval<E>()))>\nstd::unordered_map<vertex_id_t, graph_path<WEIGHT_T>>\nbellman_ford_shortest_paths(const graph<V, E, T>& graph, vertex_id_t start_vertex);\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"graph"})," The graph to extract shortest path from."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"start_vertex"})," The source vertex for the shortest paths."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"return"})," A map of target vertex IDs to shortest path structures.\nEach value contains a graph_path object representing the shortest path from the source vertex to the respective\nvertex.\nIf a vertex is unreachable from the source, its entry will be absent from the map."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>h});var s=r(6540);const a={},n=s.createContext(a);function o(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);